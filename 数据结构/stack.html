<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>栈的实现</title>
</head>
<body>
  <script>
    function Stack() {
      this.dataStore = []; // 保存栈内元素
      this.top = 0; //标记可以插入新元素的位置，栈内压入元素该变量变大；弹出元素，变量减小
      this.push = push; // 入栈操作
      this.pop = pop; // 出栈操作
      this.peek = peek; // 返回栈顶元素
      this.clear = clear; // 清空栈
      this.length = length; // 栈的长度
    }
    function push(element) {
      this.dataStore[this.top++] = element;
    }
    function pop() {
      return this.dataStore[--this.top];
    }
    function peek() {
      return this.dataStore[this.top-1];
    }
    function length() {
      return this.top;
    }
    function clear() {
      // 还清空数据
      this.top = 0;
    }
    var s = new Stack();
    s.push("小红第一");
    s.push("小黄第一");
    s.push("小绿第一");
    s.push("小蓝第一");
    console.log(s, '全部')
    console.log(s.length(), '长度');
    console.warn(s.peek(), '栈顶');
    console.warn(s.pop(), '出栈');
    /* 回文算法 */
    function isPalindrome (word) {
      var s = new Stack();
      for (var i =0; i < word.length; i++) {
        s.push(word[i]);
      }
      var rword = "";
      console.log(s);
      while (s.length() > 0) {
        rword += s.pop();
      }
      if (rword == word) {
        return true;
      } else {
        return false;
      }
    }
    var word = "=racecar=";
    alert(isPalindrome(word));
  </script>
</body>
</html>